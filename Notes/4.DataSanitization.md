# ğŸ§© Data Sanitization & Schema

A clean and secure backend starts with **strict data validation and sanitization**. Since **POST** and **PATCH** APIs are responsible for **inserting and updating data in the database**, they must be designed carefully to prevent:

* âŒ Invalid data
* âŒ Database pollution
* âŒ Security issues
* âŒ Unexpected application behavior

This document explains **Schema-level validation (Mongoose)** and **API-level validation**, along with real-world examples.

---

## ğŸ’¡ Why Data Sanitization Matters

Even if the frontend validates input, **never trust client-side data**. Users can:

* Send extra/random fields
* Bypass frontend validations
* Send extremely large payloads
* Try to update restricted fields (like `email` or `password`)

ğŸ‘‰ **Defense-in-depth** is the key:

1. Schema-level validation (Mongoose)
2. API-level validation (Express)
3. Utility-level validation (custom helpers)

---

## âš¡ Schema-Level Validation (Mongoose)

Before any data reaches the database, the **schema should act as the first gatekeeper**.

### ğŸ§± Common `SchemaType` Options

| Option       | Applies To     | Purpose                       |
| ------------ | -------------- | ----------------------------- |
| `required`   | All            | Makes field mandatory         |
| `unique`     | String, Number | Ensures unique values         |
| `default`    | All            | Sets default value            |
| `lowercase`  | String         | Converts value to lowercase   |
| `trim`       | String         | Removes extra spaces          |
| `minLength`  | String         | Minimum string length         |
| `maxLength`  | String         | Maximum string length         |
| `enum`       | String, Number | Allowed values only           |
| `match`      | String         | Regex validation              |
| `min`        | Number, Date   | Minimum value                 |
| `max`        | Number, Date   | Maximum value                 |
| `validate`   | All            | Custom validation logic       |
| `timestamps` | Schema         | Adds `createdAt`, `updatedAt` |

---

### ğŸ§  Important Notes

* If `required` fields are missing â†’ âŒ **Document will not be inserted**
* `type: [String]` creates an **empty array by default**
* `trim` is critical for **unique fields** like email
* `validate()` runs **only on create by default**

To enable validation on updates:

```js
await User.findByIdAndUpdate(id, updates, { runValidators: true });
```

---

## ğŸ§© User Schema Example

```js
const mongoose = require("mongoose");
const validator = require("validator");

const userSchema = new mongoose.Schema(
  {
    firstName: {
      type: String,
      required: true,
      minLength: 5,
      maxLength: 10,
    },
    lastName: {
      type: String,
    },
    email: {
      type: String,
      required: true,
      unique: true,
      lowercase: true,
      trim: true,
      validate(value) {
        if (!validator.isEmail(value)) {
          throw new Error("Invalid email");
        }
      },
    },
    password: {
      type: String,
      required: true,
    },
    age: {
      type: Number,
      min: 18,
      max: 90,
    },
    gender: {
      type: String,
      lowercase: true,
      trim: true,
      enum: {
        values: ["male", "female", "others"],
        message: "{VALUE} is not a valid gender",
      },
    },
    photoURL: {
      type: String,
      default:
        "https://upload.wikimedia.org/wikipedia/commons/9/99/Sample_User_Icon.png?20200919003010",
      validate(value) {
        if (!validator.isURL(value)) {
          throw new Error("Invalid URL");
        }
      },
    },
    skills: {
      type: [String],
    },
  },
  { timestamps: true }
);

module.exports = mongoose.model("User", userSchema);
```

---

## ğŸš« Why Schema Validation Is Not Enough

Even with schema validation:

* Users can send **extra fields**
* Arrays can grow **unbounded**
* Sensitive fields can be updated

ğŸ‘‰ This is where **API-level validation** is required.

---

## ğŸ›¡ï¸ API-Level Validation (PATCH API)

### ğŸ¯ Use Case

* Prevent DB pollution
* Allow only specific fields to update
* Add business rules (e.g. max 10 skills)

```js
app.patch('/user/:userId', async (req, res) => {
  const { userId } = req.params;
  const updates = req.body;

  try {
    const ALLOWED_UPDATES = ["photoURL", "about", "gender", "skills"];

    const isUpdateAllowed = Object.keys(updates).every(key =>
      ALLOWED_UPDATES.includes(key)
    );

    if (!isUpdateAllowed) {
      return res.status(400).send("Update is not allowed");
    }

    if (updates.skills && updates.skills.length > 10) {
      return res.status(400).send("Skills cannot be more than 10");
    }

    const user = await User.findByIdAndUpdate(
      userId,
      updates,
      { new: true, runValidators: true }
    );

    if (!user) {
      return res.status(404).send("User not found");
    }

    res.send(user);
  } catch (err) {
    res.status(400).send(err.message);
  }
});
```

---

## ğŸ” Encrypting Passwords (Signup Flow)

### âœ… Correct Signup Flow

1. Validate input data
2. Encrypt password
3. Create user with **explicit fields only**

---

### ğŸ§° `utils/validation.js`

```js
function validateSignupData(req) {
  const { firstName, email, password } = req.body;

  if (!firstName || !email || !password) {
    throw new Error("Missing required fields");
  }
}

module.exports = validateSignupData;
```

---

### ğŸ“ Signup API

```js
app.post("/signup", async (req, res) => {
  try {
    validateSignupData(req);

    const { firstName, lastName, email, password } = req.body;

    const passwordHash = await bcrypt.hash(password, 10);

    const user = new User({
      firstName,
      lastName,
      email,
      password: passwordHash,
    });

    await user.save();
    res.send("User created successfully");
  } catch (err) {
    res.status(400).send("Something went wrong: " + err.message);
  }
});
```

> âš ï¸ **Always use `await` with `bcrypt.hash` and `bcrypt.compare`**

---

## ğŸ”‘ Login API Validation

```js
app.post("/login", async (req, res) => {
  try {
    const { email, password } = req.body;

    if (!validator.isEmail(email)) {
      throw new Error("Invalid credentials");
    }

    const user = await User.findOne({ email });
    if (!user) {
      throw new Error("Invalid credentials");
    }

    const isPasswordValid = await bcrypt.compare(password, user.password);
    if (!isPasswordValid) {
      throw new Error("Invalid credentials");
    }

    res.send("Login successful");
  } catch (err) {
    res.status(400).send("ERROR: " + err.message);
  }
});
```

---

## âš¡ Quick Notes (Revision)

* POST & PATCH need **strict validation**
* Schema validation â‰  complete security
* Use `trim + lowercase` for unique fields
* Enable `runValidators: true` on updates
* Always whitelist allowed update fields
* Never trust `req.body` directly
* Always hash passwords
* Use `validator` for email & URL checks

---

## ğŸ§  Summary

* ğŸ§© **Schema validation** protects database structure
* ğŸ›¡ï¸ **API validation** protects business logic
* ğŸ” Passwords must always be encrypted
* âš¡ Use explicit field selection to prevent DB pollution
* ğŸ’¡ Combine schema + API validation for production-ready apps

---

âœ… This approach follows **real-world backend production standards** and keeps your application secure, scalable, and maintainable.
