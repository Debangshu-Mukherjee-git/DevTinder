# üîê Authentication, JWT & Cookies


---

## üç™ What is a Cookie?

A **cookie** is a small piece of data:

* Created by the **server**
* Stored in the **browser**
* Automatically sent with every request to the same server

üëâ Cookies help maintain **state** in stateless HTTP.

---

## üß† Why Cookies Exist

HTTP is **stateless**:

* Server does not remember previous requests

Cookies solve this by:

* Storing an identifier (sessionId / JWT)
* Sending it back on every request

---

## ‚öôÔ∏è How Cookies Work (Flow)

1. User logs in
2. Server responds with `Set-Cookie`
3. Browser stores the cookie
4. Browser auto-attaches cookie on every request

---

## üì¶ What Can a Cookie Store?

* Session ID
* JWT token
* User preferences (theme, language)
* CSRF token

---

## üîê What is JWT (JSON Web Token)?

A **JWT** is a **self-contained token** used for authentication & authorization.

**Properties:**

* Stateless
* Compact
* Signed (tamper-proof)

üëâ Server verifies user **without storing session data**.

---

## üß† Why JWT is Used

Traditional sessions need:

* Server memory (Redis / DB)

JWT removes that need:

* No server-side session storage
* All info is inside token
* Server only verifies signature

---

## ‚öôÔ∏è JWT Authentication Flow

1. User logs in
2. Server creates JWT
3. JWT sent to client (usually via cookie)
4. Client sends JWT with each request
5. Server verifies JWT ‚Üí allows access

---

## üß© Structure of JWT

A JWT has **3 parts**, separated by dots (`.`):

```
HEADER.PAYLOAD.SIGNATURE
```

| Part      | Purpose            |
| --------- | ------------------ |
| Header    | Algorithm & type   |
| Payload   | User data (claims) |
| Signature | Prevents tampering |

---

## üîê JWT Security Explained

* Payload is **not encrypted**
* Anyone can decode it
* **Never store sensitive data**

üëâ Signature ensures **data integrity**, not secrecy.

---

## ‚ö†Ô∏è JWT Interview Gold

* JWT is NOT encrypted
* Signature ‚â† Encryption
* JWT can expire
* Anyone can read payload
* Only server can create valid JWT

---

## üç™ Cookie Parsing in Express

Express does NOT parse cookies by default.

### ‚úÖ cookie-parser Middleware

```js
const cookieParser = require("cookie-parser");
app.use(cookieParser());
```

Cookies available as:

* `req.cookies`
* `req.signedCookies`

---

## üîê Signed Cookies

Signed cookies prevent tampering.

### Enable Signed Cookies

```js
app.use(cookieParser("mySecretKey"));
```

### Set Signed Cookie

```js
res.cookie("userId", "123", { signed: true });
```

### Read Signed Cookie

```js
req.signedCookies.userId;
```

‚ùå Modified cookie ‚Üí becomes `undefined`

---

## ü™™ jsonwebtoken (JWT Library)

Used to:

* Create JWT
* Verify JWT
* Decode JWT

### Sign JWT

```js
jwt.sign(payload, secret, options);
```

### Common Options

| Option    | Purpose       |
| --------- | ------------- |
| expiresIn | Token expiry  |
| issuer    | Token issuer  |
| algorithm | HS256 / RS256 |
| subject   | Token subject |

### Verify JWT

```js
const decoded = jwt.verify(token, process.env.JWT_SECRET);
```

* Valid ‚Üí returns payload
* Expired / Tampered ‚Üí throws error

---

## üîç Why Signing Matters (Critical)

Signing is NOT for hiding data.

Signing is for **preventing tampering**.

### Without Signing üö®

```json
{
  "userId": "123",
  "role": "user"
}
```

Attacker could:

* Change role ‚Üí `admin`
* Re-encode token

üî• Total security break

---

## üîê What Signing Actually Does

```
JWT = base64(header) + "." + base64(payload) + "." + signature
```

Signature is created using:

* Header + Payload
* Secret / Private key
* Algorithm (HS256 / RS256)

```js
signature = HMAC(header + payload, SECRET_KEY);
```

---

## üß™ Tampering Example

Payload changed ‚Üí signature mismatch ‚Üí token rejected

```js
jwt.verify(token, secret); // ‚ùå throws error
```

---

## üîë Password Encryption (bcrypt)

### Signup Flow

1. Validate input
2. Hash password
3. Save only required fields

```js
const passwordHash = await bcrypt.hash(password, 10);
```

‚ö†Ô∏è ALWAYS use `await` with bcrypt

---

## üßë‚Äçüíª Auth Middleware Pattern

```js
const userAuth = async (req, res, next) => {
  try {
    const { token } = req.cookies;
    if (!token) throw new Error("Unauthorized");

    const decoded = jwt.verify(token, process.env.JWT_SECRET);
    const user = await User.findById(decoded._id);

    if (!user) throw new Error("User not found");

    req.user = user;
    next();
  } catch (err) {
    res.status(401).send(err.message);
  }
};
```

---

## ‚è±Ô∏è Cookie Expiry: maxAge vs expires

### üß† One-Line Difference

* `maxAge` ‚Üí relative time
* `expires` ‚Üí absolute time

### Comparison Table

| Feature       | maxAge   | expires  |
| ------------- | -------- | -------- |
| Type          | Relative | Absolute |
| Format        | ms       | Date     |
| Timezone safe | ‚úÖ        | ‚ùå        |
| Recommended   | ‚úÖ        | ‚ö†Ô∏è       |

üëâ If both are set, **maxAge wins**

---

## üß† Session Cookies

```js
res.cookie("token", "abc");
```

* Lives until browser closes
* No expiry set

---

## üîê JWT Expiry (exp claim)

```js
jwt.sign(
  { userId: "123" },
  process.env.JWT_SECRET,
  { expiresIn: "15m" }
);
```

---

## üß© Mongoose Schema Methods

Schema methods add behavior to a document.

```js
userSchema.methods.getJWT = function () {
  return jwt.sign({ _id: this._id }, process.env.JWT_SECRET, {
    expiresIn: "15m",
  });
};
```

### Validate Password Method

```js
userSchema.methods.validatePassword = async function (inputPassword) {
  return await bcrypt.compare(inputPassword, this.password);
};
```

---

## üÜö Schema Methods vs Statics

| Feature     | Method        | Static        |
| ----------- | ------------- | ------------- |
| Attached to | Document      | Model         |
| Uses `this` | Document      | Model         |
| Example     | user.method() | User.method() |

---

## ‚ö†Ô∏è Common Mistakes

* ‚ùå Arrow functions in schema methods
* ‚ùå Business logic in routes
* ‚ùå Mixing statics & methods
* ‚ùå Forgetting `await`

---

## ‚ö° Quick Notes (Revision)

* Cookies maintain HTTP state
* JWT is stateless
* JWT is signed, not encrypted
* Never store secrets in JWT
* Use httpOnly cookies for tokens
* Always hash passwords
* Middleware = reusable auth logic

---

## üß† Summary

* Cookies store authentication state
* JWT enables stateless auth
* Signing prevents tampering
* bcrypt secures passwords
* Middleware centralizes auth logic
* `maxAge` is preferred over `expires`
* Schema methods keep code clean

‚úÖ Production-ready authentication requires **cookies + JWT + expiry + hashing + middleware**
